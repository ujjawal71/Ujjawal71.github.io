<!DOCTYPE html>
<html>
<head>
 <title>B.Tech All Branch</title>
<meta name="viewport" content="width=device-width ,initial-scale=1">
<link rel="stylesheet" type="text/css" href="css/Box.css"/>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="utf-8">

<meta http-equiv="Content-Language" content="en_us"/>
<meta name="Description" content="AKU BIHAR ALL BRANCH SYLLABUS, CSE,CIVIL,EEE,MECH">

<meta name="keyboard" content="AKU BIHAR ALL BRANCH SYLLABUS, CSE,CIVIL,EEE,MECH">
<meta name="author" content="UJJAWAL KUMAR">
<script type="text/javascript" src="js/lock.js"></script>

<style>
b
{
color:lightgreen;
line-height:1px;
}
body
{

 line-height: 20px;
    padding-bottom: 2px;
    vertical-align: middle;
color:white;
}
</style>
</head>
<body id="top" oncontextmenu="return false" onselectstart="return false" ondragstart="return false">



<style type="text/css">
.button
{
  
    background:orange;
   border:double;
   border-radius:20px;
    width: 100%;
    height: 60px; 
   
    line-height: 20px;
    padding-bottom: 2px;
    vertical-align: middle;
    font-family: "Lucida Grande", Geneva, Verdana, Arial, Helvetica, sans-serif;
    font-size: 25px;
font-size: 15px;
    font-weight: bold;
    <!--font-weight: bold;-->
    text-transform: none;
    border:1px solid transparent;
}
.button:hover
{
    //background-color: green;
background: linear-gradient(lightgray,darkturquoise);
background: -webkit-linear-gradient(lightgray,darkturquoise);
background: -moz-linear-gradient(lightgray,darkturquoise);

transform:scale(1.0);
-webkit-transform:scale(1.0);
-moz-transform:scale(1.0);
box-shadow:1px 1px 1px #000;
}


#n
{

//font-weight:bold;
border-radius:8px;
color:red;
background-color:lightgreen;
text-shadow:5px 5px 8px green;
line-height:35px;
width:120px;
height:35px;
}
#rig
{
    
text-align:right;

}
#Kp
{
animation-duration : 1000ms;
animation-name: R;
animation-iteration-count: infinite;
animation-direction:alternate;
}
@keyframes R
{
from
{
opacity: 1;

color:blue;
}
to
{
opacity: 56;

color:red;
}}

a
{
text-decoration:none;
}
</style>

<br/>
<center>
<p style="font-weight:bold;color:pink;font-size:20px;">IT 4th Sem</p>
</center>


<script type="text/javascript">
function toggleMe(a){
var e=document.getElementById(a);
if(!e)return true;
if(e.style.display=="none"){
e.style.display="block"
}
else{
e.style.display="none"
}
return true;
}
</script>


<br/>
<center>
<p style="font-size: 20px;color:white;" ><span id="Kp">NEW SYLLABUS</span> </p>

</center>
<br/>


<input type="button" onclick="return toggleMe('1')" value="Formal Language & Automata
Theory" class="button"><br>
<span id="1" style='display:none'><p > <br><b>Formal Language & Automata
Theory</b><br/>

<b>Objectives of the course</b><br/>
1. To develop a formal notation for strings, languages and machines.<br/>
2. To design finite automata to accept a set of strings of a language.<br/>
3. To prove that a given language is regular and apply the closure properties of
languages.<br/>
4. Design context free grammars to generate strings from a context free
language and convert them into normal forms.<br/>
5. Prove equivalence of languages accepted by Push Down Automata
andlanguages generated by context free grammars<br/>
6. Identify the hierarchy of formal languages, grammars and machines.<br/>
7. Distinguish between computability and non-computability and Decidability and
undesirability<br/><br/>

Module 1 Lecture 10 hrs.<br/>
Introduction: Alphabet, languages and grammars, productions and derivation,
Chomsky hierarchy of languages.
Regular languages and finite automata: Regular expressions and languages,
deterministic finite automata (DFA) and equivalence with regular expressions,
nondeterministic finite automata (NFA) and equivalence with DFA, regular grammars
and equivalence with finite automata, properties of regular languages, pumping lemma
for regular languages, minimization of finite automata.<br/><br/>

Module 2 Lecture 10 hrs.<br/>
Context-free languages and pushdown automata: Context-free grammars (CFG) and
Context-free languages (CFL), Chomsky and Greibach normal forms, nondeterministic
pushdown automata (PDA) and equivalence with CFG, parse trees, ambiguity in CFG,
pumping lemma for context-free languages, deterministic pushdown automata, closure
properties of CFLs.<br/><br/>

Module 3 Lecture 2 hrs<br/>
Context-sensitive languages: Context-sensitive grammars (CSG) and Contextsensitive languages, linear bounded automata and equivalence with CSG.<br/><br/>

Module 4 Lecture 10 hrs.<br/>
Turing machines: The basic model for Turing machines (TM), Turing recognizable(Recursively enumerable) and Turing-decidable (recursive) languages and their closure
properties, variants of Turing machines, nondeterministic TMs and equivalence with
deterministic TMs, unrestricted grammars and equivalence with Turing machines, TMs
as enumerators.<br/><br/>

Module 5 Lecture 8 hrs.<br/>
Undecidability: Church-Turing thesis, universal Turing machine, the universal and
diagonalization languages, reduction between languages and Rice’s theorem,
undecidable problems about languages.<br/><br/>

<b>Suggested books</b><br/>
• John E. Hopcroft, Rajeev Motwani and Jeffrey D. Ullman, Introduction to
Automata Theory, Languages, and Computation, Pearson Education Asia.<br/><br/>
<b>Suggested reference books:</b><br/>
1. Harry R. Lewis and Christos H. Papadimitriou, Elements of the
Theory of Computation, Pearson EducationAsia.<br/>
2. Dexter C. Kozen, Automata and Computability, Undergraduate Texts in
Computer Science, Springer.<br/>
3. Michael Sipser, Introduction to the Theory of Computation, PWS Publishing.<br/>
4. John Martin, Introduction to Languages and the Theory of
Computation, Tata McGraw Hill.




</p>
 </span>
<br>


<input type="button" onclick="return toggleMe('2')" value="Computer Organization &
Architecture" class="button"><br>
<span id="2" style='display:none'><p > <br><b>Computer Organization &
Architecture</b><br/>


<b>Objectives of the course</b><br/>
To expose the students to the following:<br/>
1. How Computer Systems work & the basic principles<br/>
2. Instruction Level Architecture and Instruction Execution<br/>
3. The current state of art in memory system design<br/>
4. How I/O devices are accessed and its principles.<br/>
5. To provide the knowledge on Instruction Level Parallelism<br/>
6. To impart the knowledge on microprogramming<br/>
7. Concepts of advanced pipe lining techniques.<br/>
<br/>
Module 1: Lecture 10<br/>
Functional blocks of a computer: CPU, memory, input-output subsystems, control unit.
Instruction set architecture of a CPU–registers, instruction execution cycle, RTL
interpretation of instructions, addressing modes, instruction set. Case study – instruction
sets of some common CPUs.
Data representation: signed number representation, fixed and floating point
representations, character representation. Computer arithmetic – integer addition and
subtraction, ripple carry adder, carry look-ahead adder, etc. multiplication – shift-and-add,
Booth multiplier, carry save multiplier, etc. Division restoring and non-restoring techniques,
floating point arithmetic.<br/><br/>

Module 2: Lecture 14<br/>
Introduction to x86 architecture.
CPU control unit design: hardwired and micro-programmed design approaches, Case study
– design of a simple hypothetical CPU.
Memory system design: semiconductor memory technologies, memory organization.
Peripheral devices and their characteristics: Input-output subsystems, I/O
device interface, I/O transfers–program controlled, interrupt driven and DMA, privileged
and non-privileged instructions, software interrupts and exceptions. Programs and
processes–role of interrupts in process state transitions, I/O device interfaces – SCII, USB.
<br/><br/>
Module 3: Lecture 10<br/>
Pipelining: Basic concepts of pipelining, throughput and speedup, pipeline hazards.
Parallel Processors: Introduction to parallel processors, Concurrent access to memory and
cache coherency.<br/><br/>
Module 4: Lecture 6<br/>
Memory organization: Memory interleaving, concept of hierarchical memory organization,
cache memory, cache size vs. Block size, mapping functions, replacement algorithms, write
policies.<br/><br/>

<b>Suggested books:</b><br/>
1. “Computer Organization and Design: The Hardware/Software Interface”, 5th Edition
by David A. Patterson and John L. Hennessy, Elsevier.<br/>
2. “Computer Organization and Embedded Systems”, 6th Edition by Carl Hamacher,
McGraw Hill Higher Education.<br/>
3. “Computer Architecture and Organization”, 3rd Edition by John P. Hayes,
WCB/McGraw-Hill<br/>
4. “Computer Organization and Architecture: Designing for Performance”, 10th Edition
by William Stallings, Pearson Education.<br/>
5. “Computer System Design and Architecture”, 2nd Edition by Vincent P. Heuring and
Harry F. Jordan, Pearson Education.<br/>





</p>
 </span>
<br>

<input type="button" onclick="return toggleMe('3')" value="Machine Learning" class="button"><br>
<span id="3" style='display:none'><p > <br><b>Machine Learning</b><br/>

Objectives of the course<br/>
1. To learn the concept of how to learn patterns and concept from data.<br/>
2. Design and analyze various machine learning algorithms and their applications in recent
trends.<br/>
3. Evaluate the various factors of machine learning to measure the performance.<br/>
4. Understand basic of machine learning’s application in recent trend of technology.<br/>
UNIT 1:
Introduction: Basic definitions, Linear Algebra, Statistical learning theory, types of learning,
hypothesis space and Inductive bias, evaluation and cross validation, Optimization.<br/>

UNIT 2:
Statistical Decision Theory, Bayesian Learning (ML, MAP, Bayes estimates, Conjugate priors), Linear
Regression, Ridge Regression, Lasso, Principal Component Analysis, Partial Least Squares<br/>

UNIT3:
Linear Classification, Logistic Regression, Linear Discriminant Analysis, Quadratic Discriminant
Analysis, Perceptron, Support Vector Machines + Kernels, Artificial Neural Networks + Back
Propagation, Decision Trees, Bayes Optimal Classifier, Naive Bayes.<br/>

UNIT 4:
Hypothesis testing, Ensemble Methods, Bagging Adaboost Gradient Boosting, Clustering, K-means, Kmedoids, Density-based Hierarchical, Spectral .<br/>
UNIT 5:
Expectation Maximization, GMMs, Learning theory Intro to Reinforcement Learning ,Bayesian
Networks.<br/><br/>
<b>Suggested books:</b><br/>
1. Machine Learning. Tom Mitchell. First Edition, McGraw- Hill, 1997<br/>
2. Introduction to Machine Learning Edition 2, by EthemAlpaydin<br/>

3. J. Shavlik and T. Dietterich (Ed), Readings in Machine Learning, Morgan Kaufmann, 1990.<br/>
4. P. Langley, Elements of Machine Learning, Morgan Kaufmann, 1995.<br/>
5. Understanding Machine Learning. Shai Shalev-Shwartz and Shai Ben-David. Cambridge
University Press. 2017. [SS-2017]<br/>
6. The Elements of Statistical Learning. Trevor Hastie, Robert Tibshirani and Jerome Friedman.<br/>

</p>
 </span>
<br>

<input type="button" onclick="return toggleMe('4')" value="Database Management Systems" class="button"><br>
<span id="4" style='display:none'><p > <br><b>Database Management Systems</b><br/>

<b>Objectives of the course</b><br/>
1. To understand the different issues involved in the design and implementation of a
database system.<br/>
2. To study the physical and logical database designs, database modeling, relational,
hierarchical, and network models<br/>
3. To understand and use data manipulation language to query, update, and manage a
database<br/>
4. To develop an understanding of essential DBMS concepts such as: database security,
integrity, concurrency, distributed database, and intelligent database, Client/Server
(Database Server), Data Warehousing.<br/>

5. To design and build a simple database system and demonstrate competence with
the fundamental tasks involved with modeling, designing, and implementing a
DBMS.
<br/><br/>
Module 1: Lecture 6<br/>
Database system architecture: Data Abstraction, Data Independence, Data Definition
Language (DDL), Data Manipulation Language (DML).
Data models: Entity-relationship model, network model, relational and object oriented data
models, integrity constraints, data manipulation operations.<br/><br/>

Module 2: Lecture 10<br/>
Relational query languages: Relational algebra, Tuple and domain relational
calculus, SQL3, DDL and DML constructs, Open source and Commercial DBMS - MYSQL,
ORACLE, DB2, SQL server.
Relational database design: Domain and data dependency, Armstrong’s axioms, Normal
forms, Dependency preservation, Lossless design.
Query processing and optimization: Evaluation of relational algebra expressions, Query
equivalence, Join strategies, Query optimization algorithms.<br/><br/>

Module 3: Lecture 4<br/>
Storage strategies: Indices, B-trees, hashing.Module 4: Lecture 8
Transaction processing: Concurrency control, ACID property, Serializability of scheduling,
Locking and timestamp based schedulers, Multi-version and optimistic Concurrency Control
schemes, Database recovery.<br/><br/>

Module 5: Lecture 6<br/>
Database Security: Authentication, Authorization and access control, DAC, MAC and RBAC
models, Intrusion detection, SQL injection.<br/><br/>

Module 6: Lecture 6<br/>
Advanced topics: Object oriented and object relational databases, Logical databases, Web
databases, Distributed databases, Data warehousing and data mining.<br/><br/>
<b>Suggested books:</b><br/>
1. “Database System Concepts”, 6th Edition by Abraham Silberschatz, Henry
F. Korth, S. Sudarshan, McGraw-Hill<br/>
2. “Principles of Database and Knowledge – Base Systems”, Vol 1 by J. D. Ullman,
Computer Science Press.<br/>
3. “Fundamentals of Database Systems”, 5th Edition by R. Elmasri and S. Navathe,
Pearson Education<br/>
4. “Foundations of Databases”, Reprint by Serge Abiteboul, Richard Hull, Victor Vianu,
Addison-Wesley<br/><br/>

<b>Course Outcomes</b><br/>
1. For a given query write relational algebra expressions for that query and optimize
the developed expressions<br/>
2. For a given specification of the requirement design the databases using E R method
and normalization.<br/>
3. For a given specification construct the SQL queries for Open source and
Commercial DBMS -MYSQL, ORACLE, and DB2.<br/>
4. For a given query optimize its execution using Query optimization algorithms<br/>
5. For a given transaction-processing system, determine the transaction atomicity,
consistency, isolation, and durability.<br/>
6. Implement the isolation property, including locking, time stamping based on
concurrency control and Serializability of scheduling.<br/>

</p>
 </span>
<br>
 

<br/>
<br/>
<br/>
<br/>



</body>
</html>