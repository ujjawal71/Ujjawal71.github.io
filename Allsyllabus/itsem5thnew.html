<!DOCTYPE html>
<html>
<head>
 <title>B.Tech All Branch</title>
<meta name="viewport" content="width=device-width ,initial-scale=1">
<link rel="stylesheet" type="text/css" href="css/Box.css"/>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="utf-8">

<meta http-equiv="Content-Language" content="en_us"/>
<meta name="Description" content="AKU BIHAR ALL BRANCH SYLLABUS, CSE,CIVIL,EEE,MECH">

<meta name="keyboard" content="AKU BIHAR ALL BRANCH SYLLABUS, CSE,CIVIL,EEE,MECH">
<meta name="author" content="UJJAWAL KUMAR">
<script type="text/javascript" src="js/lock.js"></script>

<style>
b
{
color:lightgreen;
line-height:1px;
}
body
{

 line-height: 20px;
    padding-bottom: 2px;
    vertical-align: middle;
color:white;

}
</style>
</head>
<body id="top" oncontextmenu="return false" onselectstart="return false" ondragstart="return false">



<style type="text/css">
.button
{
  
    background:orange;
   border:double;
   border-radius:20px;
    width: 100%;
    height: 60px; 
   
    line-height: 20px;
    padding-bottom: 2px;
    vertical-align: middle;
    font-family: "Lucida Grande", Geneva, Verdana, Arial, Helvetica, sans-serif;
    font-size: 25px;
font-size: 15px;
    font-weight: bold;
    <!--font-weight: bold;-->
    text-transform: none;
    border:1px solid transparent;
}
.button:hover
{
    //background-color: green;
background: linear-gradient(lightgray,darkturquoise);
background: -webkit-linear-gradient(lightgray,darkturquoise);
background: -moz-linear-gradient(lightgray,darkturquoise);

transform:scale(1.0);
-webkit-transform:scale(1.0);
-moz-transform:scale(1.0);
box-shadow:1px 1px 1px #000;

}


#n
{

//font-weight:bold;
border-radius:8px;
color:red;
background-color:lightgreen;
text-shadow:5px 5px 8px green;
line-height:35px;
width:120px;
height:35px;
}
#rig
{
    
text-align:right;

}
#Kp
{
animation-duration : 1000ms;
animation-name: R;
animation-iteration-count: infinite;
animation-direction:alternate;
}
@keyframes R
{
from
{
opacity: 1;

color:blue;
}
to
{
opacity: 56;

color:red;
}}

a
{
text-decoration:none;
}
</style>

<br/>
<center>
<p style="font-weight:bold;color:pink;font-size:20px;">IT 5th Sem</p>
</center>

<script type="text/javascript">
function toggleMe(a){
var e=document.getElementById(a);
if(!e)return true;
if(e.style.display=="none"){
e.style.display="block"
}
else{
e.style.display="none"
}
return true;
}
</script>

<br/>
<center>
<p style="font-size: 20px;color:white;" ><span id="Kp">NEW SYLLABUS</span> </p>

</center>
<br>

<input type="button" onclick="return toggleMe('1')" value="Design and Analysis of Algorithms" class="button"><br>
<span id="1" style='display:none'><p> <br><b>Design and Analysis of Algorithms</b><br/>
    <br/><br/>

<b>Objectives of the course</b><br/><br/>

1. Analyze the asymptotic performance of algorithms.<br/><br/>
2. Write rigorous correctness proofs for algorithms.<br/><br/>
3. Demonstrate a familiarity with major algorithms and data structures.<br/><br/>
4. Apply important algorithmic design paradigms and methods of analysis.<br/><br/>
5. Synthesize efficient algorithms in common engineering design situations.<br/><br/>

<span id="red">Module 1:</span> Lecture 10Introduction: Characteristics of algorithm. Analysis of algorithm: Asymptotic analysis of
complexity bounds – best, average and worst-case behavior; Performance measurements
of Algorithm, Time and space trade-offs, Analysis of recursive algorithms through
recurrence relations: Substitution method, Recursion tree method and Masters’ theorem.<br/><br/>

<span id="red">Module 2:</span> Lecture 10
Fundamental Algorithmic Strategies: Brute-Force, Greedy, Dynamic Programming, Branchand-Bound and Backtracking methodologies for the design of algorithms; Illustrations of
these techniques for Problem-Solving , Bin Packing, Knap Sack TSP. Heuristics – characteristics
and their application domains. <br/><br/>

<span id="red">Module 3:</span> Lecture 10
Graph and Tree Algorithms: Traversal algorithms: Depth First Search (DFS) and Breadth First
Search (BFS); Shortest path algorithms, Transitive closure, Minimum Spanning Tree,
Topological sorting, Network Flow Algorithm. <br/><br/>

<span id="red">Module 4:</span> Lecture 6
Tractable and Intractable Problems: Computability of Algorithms, Computability classes – P,
NP, NP-complete and NP-hard. Cook’s theorem, Standard NP-complete problems and
Reduction techniques.<br/><br/>

<span id="red">Module 5:</span> Lecture 4
Advanced Topics: Approximation algorithms, Randomized algorithms, Class of problems
beyond NP – P SPACE <br/><br/>

<b>Suggested books:</b><br/><br/>

1. Introduction to Algorithms, 4TH Edition, Thomas H Cormen, Charles E Lieserson,
Ronald L Rivest and Clifford Stein, MITPress/McGraw-Hill.<br/><br/>

2. Fundamentals of Algorithms – E. Horowitz etal.<br/><br/>

<b>Suggested reference books</b><br/><br/>

1. Algorithm Design, 1ST Edition, Jon Kleinberg and ÉvaTardos, Pearson.<br/><br/>
2. Algorithm Design: Foundations, Analysis, and Internet Examples, Second Edition,
Michael T Goodrich and Roberto Tamassia, Wiley.<br/><br/>
3. Algorithms - A Creative Approach, 3RD Edition, UdiManber, Addison-Wesley, Reading,
MA.<br/><br/>

<b>Course Outcomes</b><br/><br/>

1. For a given algorithms analyze worst-case running times of algorithms based on
asymptotic analysis and justify the correctness of algorithms.<br/><br/>

2. Describe the greedy paradigm and explain when an algorithmic design situation calls
for it. For a given problem develop the greedy algorithms.<br/><br/>

3. Describe the divide-and-conquer paradigm and explain when an algorithmic design
situation calls for it. Synthesize divide-and-conquer algorithms. Derive and solve
recurrence relation.<br/><br/>

4. Describe the dynamic-programming paradigm and explain when an algorithmic design
situation calls for it. For a given problems of dynamic-programming and develop the
dynamic programming algorithms, and analyze it to determine its computational
complexity.<br/><br/>

5. For a given model engineering problem model it using graph and write the
corresponding algorithm to solve the problems.<br/><br/>

6. Explain the ways to analyze randomized algorithms (expected running time,
probability of error).<br/><br/>

7. Explain what an approximation algorithm is. Compute the approximation factor of an
approximation algorithm (PTAS and FPTAS).


</p>
 </span>
<br/>



<input type="button" onclick="return toggleMe('2')" value="Complier Design" class="button"><br>
<span id="2" style='display:none'><p> <br><b>Complier Design</b><br/>
    <br/><br/>

<b>Objectives of the course</b><br/><br/>
1. To understand and list the different stages in the process of compilation.<br/><br/>
2. Identify different methods of lexical analysis<br/><br/>
3. Design top-down and bottom-upparsers<br/><br/>
4. Identify synthesized and inherited attributes<br/><br/>
5. Develop syntax directed translation schemes<br/><br/>
6. Develop algorithms to generate code for a target machine<br/><br/>
7. The aim is to learn how to design and implement a compiler and also to study the
underlying theories.<br/><br/>
8. The main emphasis is for the imperative language. <br/><br/>

Module 1 Lecture: 6
Introduction: Phases of compilation and overview.
Lexical Analysis (scanner): Regular languages, finite automata, regular expressions, from
regular expressions to finite automata, scanner generator (lex, flex).<br/><br/>

Module 2 Lecture: 9Syntax Analysis (Parser): Context-free languages and grammars, push-down automata, LL(1)
gram-mars and top-down parsing, operator grammars, LR(O), SLR(1), LR(1), LALR(1) grammars
and bottom-up parsing, ambiguity and LR parsing, LALR(1) parser generator (yacc, bison)<br/><br/>

Module 3 Lecture: 10
Semantic Analysis: Attribute grammars, syntax directed definition, evaluation and flow of
attribute in a syntax tree.
Symbol Table: Its structure, symbol attributes and management. Run-time environment:
Procedure activation, parameter passing, value return, memory allocation, and scope.<br/><br/>

Module 4 Lecture: 10
Intermediate Code Generation: Translation of different language features, different types of
intermediate forms.
Code Improvement (optimization) Analysis: control-flow, data-flow dependence etc.; Code
improvement local optimization, global optimization, loop optimization, peep-hole
optimization etc.
Architecture dependent code improvement: instruction scheduling (for pipeline), loop
optimization (for cache memory) etc. Register allocation and target code generation.<br/><br/>

Module 5 Lecture: 5
Advanced topics: Type systems, data abstraction, compilation of Object Oriented features and
non-imperative programming languages.<br/><br/>

<b>Suggested Books:</b><br/><br/>

1. Compilers Principles. Techniques. And Tools by Alfred V. Aho. Ravi Sethi Jeffery D.Ullman. 
PearsonEducation.<br/><br/>

<b>Suggested Reference Book</b><br/><br/>

1. Compiler Design by Santanu Chattopadhyay. PHI<br/><br/>
2. Modern Compiler Design by Dick Grune . E. Bal. Ceriel J. H. Jacobs. And Koen G.
Langendoen Viley Dreamtech.<br/><br/>

<b>Course Outcomes</b><br/><br/>
1. For a given grammar specification develop the lexical analyser<br/><br/>
2. For a given parser specification design top-down and bottom-up parsers<br/><br/>
3. Develop syntax directed translation schemes
Develop algorithms to generate code for a target machine

</p>
 </span>
<br/>


<input type="button" onclick="return toggleMe('3')" value="Operating Systems" class="button"><br>
<span id="3" style='display:none'><p> <br><b>Operating Systems</b><br/>
    <br/><br/>

<b>Objectives of the course</b><br/><br/>
To learn the fundamentals of Operating Systems.<br/><br/>
1. To learn the mechanisms of OS to handle processes and threads and their
communication<br/><br/>
2. To learn the mechanisms involved in memory management in contemporary OS<br/><br/>

3. To gain knowledge on distributed operating system concepts that includes
architecture, Mutual exclusion algorithms, deadlock detection algorithms and
agreement protocols<br/><br/>

4. To know the components and management aspects of concurrency management<br/><br/>

5. To learn to implement simple OS mechanisms<br/><br/>

<span id="red">Module 1:</span> Lecture 4
Introduction: Concept of Operating Systems, Generations of Operating systems, Types of
Operating Systems, OS Services, System Calls, Structure of an OS-Layered, Monolithic,
Microkernel Operating Systems, Concept of Virtual Machine. Case study on UNIX and
WINDOWS Operating System. <br/><br/>

<span id="red">Module 2:</span> Lecture 10
Processes: Definition, Process Relationship, Different states of a Process, Process State
transitions, Process Control Block (PCB), Context switching
Thread: Definition, Various states, Benefits of threads, Types of threads, Concept of
multithreads<br/><br/>

Process Scheduling: Foundation and Scheduling objectives, Types of Schedulers, Scheduling
criteria: CPU utilization, Throughput, Turnaround Time, Waiting Time, Response Time;
Scheduling algorithms: Pre-emptive and Non pre-emptive, FCFS, SJF, RR; Multiprocessor
scheduling: Real Time scheduling: RM and EDF. <br/><br/>

<span id="red">Module 3:</span> Lecture 5
Inter-process Communication: Critical Section, Race Conditions, Mutual Exclusion, Hardware
Solution, Strict Alternation, Peterson’s Solution, The Producer\ Consumer Problem,
Semaphores, Event Counters, Monitors, Message Passing, Classical IPC Problems: Reader’s &
Writer Problem, Dinning Philosopher Problemetc.<br/><br/>

<span id="red">Module 4:</span> Lecture 5
Deadlocks: Definition, Necessary and sufficient conditions for Deadlock, Deadlock
Prevention, and Deadlock Avoidance: Banker’s algorithm, Deadlock detection and Recovery.<br/><br/>

<span id="red">Module 5:</span> Lecture 8
Memory Management: Basic concept, Logical and Physical address map, Memory allocation:
Contiguous Memory allocation – Fixed and variable partition–Internal and External
fragmentation and Compaction; Paging: Principle of operation – Page allocation – Hardware
support for paging, Protection and sharing, Disadvantages ofpaging.<br/>
Virtual Memory: Basics ofVirtual Memory – Hardware and control structures – Locality of
reference, Page fault , Working Set , Dirty page/Dirty bit – Demand paging, Page
Replacement algorithms: Optimal, First in First Out (FIFO), Second Chance (SC), Not
recently used (NRU) and Least Recently used(LRU). <br/><br/>

<span id="red">Module 6:</span> Lecture 6
I/O Hardware: I/O devices, Device controllers, Direct memory access Principles of I/O
Software: Goals of Interrupt handlers, Device drivers, Device independent I/O software,
Secondary-Storage Structure: Disk structure, Disk scheduling algorithms<br/>
File Management: Concept of File, Access methods, File types, File operation, Directory
structure, File System structure, Allocation methods (contiguous, linked, indexed), 
Freespace management (bit vector, linked list, grouping), directory implementation (linear list,
hash table), efficiency andperformance.
Disk Management: Disk structure, Disk scheduling - FCFS, SSTF, SCAN, C-SCAN, Disk reliability,
Disk formatting, Boot-block, Bad blocks<br/><br/>

<b>Suggested books:</b><br/><br/>

1. Operating System Concepts Essentials, 9th Edition by AviSilberschatz, Peter Galvin,
Greg Gagne, Wiley Asia Student Edition. <br/><br/>

2. Operating Systems: Internals and Design Principles, 5th Edition, William Stallings,
Prentice Hall of India.<br/><br/>

<b>Suggested reference books:</b><br/><br/>

1. Operating System: A Design-oriented Approach, 1st Edition by Charles Crowley, Irwin
Publishing<br/><br/>

2. Operating Systems: A Modern Perspective, 2nd Edition by Gary J. Nutt, AddisonWesley<br/><br/>

3. Design of the Unix Operating Systems, 8th Edition by Maurice Bach, Prentice-Hall of
India4. Understanding the Linux Kernel, 3rd Edition, Daniel P. Bovet, MarcoCesati, O'Reilly
and Associates<br/><br/>

<b>Course Outcomes</b><br/><br/>

1. Create processes and threads.<br/><br/>
2. Develop algorithms for process scheduling for a given specification o f CPU
utilization, Throughput, Turnaround Time, Waiting Time, and Response Time. <br/><br/>

3. For a given specification of memory organization develop the techniques for
optimally allocating memory to processes by increasing memory utilization and
for improving the access time.<br/><br/>

4. Design and implement file management system<br/><br/>

5. For a given I/O devices and OS (specify) develop the I/O management functions in OS
as part of a uniform device abstraction by performing operations for synchronization
between CPU and I/O controllers.

</p>
 </span>
<br/>


<input type="button" onclick="return toggleMe('4')" value="Microprocessors" class="button"><br>
<span id="4" style='display:none'><p> <br><b>Microprocessors</b><br/>
    <br/><br/>

<b>Course Outcomes:</b><br/><br/>
At the end of this course, students will demonstrate the ability to<br/><br/>
1. Do assembly language programming.<br/><br/>
2. Do interfacing design of peripherals like I/O, A/D, D/A, timer etc.<br/><br/>
3. Develop systems using different microcontrollers.<br/><br/>

Module 1: Fundamentals of Microprocessors: (7 Hours)
Fundamentals of Microprocessor Architecture. 8-bitMicroprocessor and Microcontroller
architecture, Comparison of 8-bit microcontrollers, 16-bit and 32-bit microcontrollers.
Definition of embedded system and its characteristics, Role of microcontroller sin
embedded Systems. Overview of the 8051family.<br/><br/>

Module 2: The 8051 Architecture (8 Hours)
InternalBlockDiagram,CPU,ALU,address,dataandcontrolbus,Workingregisters,SFRs,
Clock and RESET circuits, Stack and Stack Pointer, Program Counter, I/O ports,
Memory Structures, Data and Program Memory, Timing diagrams and ExecutionCycles.<br/><br/>

Module 3: Instruction Set and Programming (8 Hours)
Addressing modes: Introduction, Instruction syntax, Data types, Subroutines Immediate
addressing, Register addressing, Direct addressing, Indirect addressing, Relative addressing,
Indexed addressing, Bit inherent addressing, bit direct addressing. 8051 Instruction set,
Instruction timings. Data transfer instructions, Arithmetic instructions, Logical instructions,
Branch instructions, Subroutine instructions, Bit manipulation instruction. Assembly language
programs, C language programs. Assemblers and compilers. Programming and debugging tools.<br/><br/>

Module 4: Memory and I/O Interfacing (6 Hours):
Memory and I/O expansion buses, control signals, memory wait states. Interfacing of
peripheral devices such as General Purpose I/O, ADC, DAC, timers, counters, memory
devices.<br/><br/>

Module 5: External Communication Interface (6 Hours)
Synchronous and Asynchronous Communication. RS232, SPI, I2C. Introduction and interfacing
to protocols like Blue-tooth and Zig-bee. <br/><br/>

Module 6: Applications (6 Hours)
LED, LCD and keyboard interfacing. Stepper motor interfacing, DC Motor interfacing, sensor
interfacing. <br/><br/>

<b>Text Book / References:</b><br/><br/>

1. M. A.Mazidi, J. G. Mazidi and R. D. McKinlay, “The 8051 Microcontroller and Embedded
Systems: Using Assembly and C”,Pearson Education,2007. <br/><br/>

2. K.J. Ayala, “8051 Microcontroller”, Delmar CengageLearning,2004. <br/><br/>

3. R. Kamal, “Embedded System”, McGraw HillEducation,2009.<br/><br/>

4. R. S. Gaonkar, “, Microprocessor Architecture: Programming and Applications with the
8085”, Penram International Publishing,1996<br/><br/>
5. D.A. Patterson and J.H. Hennessy, "Computer Organization and Design:
The Hardware/Software interface”, Morgan Kaufman Publishers,2013.<br/><br/>

6. D. V. Hall, “Microprocessors & Interfacing”, McGraw Hill Higher Education,1991.

</p>
 </span>
<br/>


<input type="button" onclick="return toggleMe('5')" value="Professional Skill Development" class="button"><br>
<span id="5" style='display:none'><p> <br><b>Professional Skill Development</b><br/>
<br/>

<b>Objectives of the course:</b><br/><br/>

1. To learn various interpersonal skills<br/><br/>
2. To help in developing various professionals skills.<br/><br/>
3. To cover the facets of verbal and non-verbal languages, public speech, reading
gestures and body languages, preparing for group discussion and enhancing
presentations skills.4. To enable learners to speak fluently and flawlessly in all kinds of communicative
Contexts with speakers of all nationalities.<br/><br/>

Module 1 Lecture 10 hrs.
Communication skills: Public speaking, Group discussion, Gestures and body language &
professional presentation skills <br/><br/>

Module 2 Lecture 10 hrs.
Interpersonal skills: Group dynamics, Negotiation skills, Leadership, Emotional intelligence<br/><br/>

Module 3 Lecture 10 hrs.
Employability and Corporate Skills: Time management and effective planning, Stress
management, People skills, Team work, development of leadership qualities, Decision making
and Negotiation skills, Positive attitude, Self-motivation, Professional ethics, Business
etiquettes, balancing board room. <br/><br/>

Module 4 Lecture 10 hrs.
Business writing skills, Resume Writing. Interview Skills, Technical Presentation, Guest
Lecture, Professional Ethics, Project Management, Entrepreneurship.<br/><br/>

<b>Suggested reference books:</b><br/><br/>

1. “Personality Development and Soft Skills”, Barun Mitra, Oxford University Press.<br/><br/>
2. “Managing Soft Skills for Personality Development”, B.N. Ghosh, McGraw Hill.<br/><br/>
3. “Communication Skills and Soft Skills: An Integrated Approach”, E. Suresh Kumar,
Pearson<br/><br/>
4. “Communication to Win”, Richard Denny, Kogan Page India Pvt. Ltd.
Course outcomes<br/><br/>
1. Student can able to write their resume and can prepare for presentation, group
discussion and interview.<br/><br/>
2. Student can develop interpersonal skills like negotiation and leadership skills.<br/><br/>
3. Students can develop Employability and Corporate Skills with proper time
management and stress management.<br/><br/>
4. Students learn to practice the professional ethics, project management and
Entrepreneurship.

</p>
 </span>
<br/>

<input type="button" onclick="return toggleMe('6')" value="Constitution of India -Basic" class="button"><br>
<span id="6" style='display:none'><p> <br><b>Constitution of India – Basic features
and fundamental principles</b><br/>
<br/>


The Constitution of India is the supreme law of India. Parliament of India cannot make any
law which violates the Fundamental Rights enumerated under the Part III of the
Constitution. The Parliament of India has been empowered to amend the Constitution
under Article 368, however, it cannot use this power to change the “basic structure”
of the constitution, which has been ruled and explained by the Supreme Court of
India in its historical judgments. The Constitution of India reflects the idea of
“Constitutionalism” – a modern and progressive concept historically developed by the
thinkers of “liberalism” – an ideology which has been recognized as one of the most popular
political ideology and result of historical struggles against arbitrary use of sovereign power
by state. The historic revolutions in France, England, America and particularly European
Renaissance and Reformation movement have resulted into progressive legal reforms
in the form of “constitutionalism” in many countries. The Constitution of India was
made by borrowing models and principles from many countries including United Kingdom
and America.
The Constitution of India is not only a legal document but it also reflects social,
political and economic perspectives of the Indian Society. It reflects India’s legacy of
“diversity”. It has been said that Indian constitution reflects ideals of its freedom
movement, however, few critics have argued that it does not truly incorporate our
own ancient legal heritage and cultural values. No law can be “static” and therefore the
Constitution of India has also been amended more than one hundred times. These
amendments reflect political, social and economic developments since the year 1950.
The Indian judiciary and particularly the Supreme Court of India has played an historic role
as the guardian of people. It has been protecting not only basic ideals of the Constitution
but also strengthened the same through progressive interpretations of the text of the
Constitution. The judicial activism of the Supreme Court of India and its historic
contributions has been recognized throughout the world and it gradually made it “as one of
the strongest court in the world”.  <br/><br/>

<b>Course content:</b><br/><br/>

1. Meaning of the constitution law and constitutionalism <br/><br/>
2. Historical perspective of the Constitution of India<br/><br/>
3. Salient features and characteristics of the Constitution of India<br/><br/>
4. Scheme of the fundamental rights<br/><br/>

5. The scheme of the Fundamental Duties and its legal status<br/><br/>
6. The Directive Principles of State Policy – Its importance and implementation<br/><br/>
7. Federal structure and distribution of legislative and financial powers between the Union
and the States<br/><br/>
8. Parliamentary Form of Government in India – The constitution powers and status of the
President of India<br/><br/>
9. Amendment of the Constitutional Powers and Procedure<br/><br/>
10. The historical perspectives of the constitutional amendments in India<br/><br/>
11. Emergency Provisions: National Emergency, President Rule, Financial Emergency<br/><br/>
12. Local Self Government – Constitutional Scheme in India<br/><br/>
13. Scheme of the Fundamental Right to Equality<br/><br/>
14. Scheme of the Fundamental Right to certain Freedom under Article 19<br/><br/>
15. Scope of the Right to Life and Personal Liberty under Article21.<br/><br/>



</p>
 </span>
<br/>


<br/>
<br/>
<br/>

</body>
</html>